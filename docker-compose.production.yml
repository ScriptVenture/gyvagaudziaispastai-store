# Production environment configuration
# Usage: docker-compose -f docker-compose.yml -f docker-compose.production.yml up

version: '3.8'

services:
  # In production, we typically use managed databases (RDS, ElastiCache)
  # These services are commented out but available for self-hosted setups
  # postgres:
  #   restart: unless-stopped
  #   environment:
  #     POSTGRES_USER: ${POSTGRES_USER}
  #     POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
  #     POSTGRES_DB: ${POSTGRES_DB}

  # redis:
  #   restart: unless-stopped

  backend:
    restart: unless-stopped
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}  # AWS RDS URL
      - REDIS_URL=${REDIS_URL}        # AWS ElastiCache URL
      - JWT_SECRET=${JWT_SECRET}
      - COOKIE_SECRET=${COOKIE_SECRET}
      - STORE_CORS=${STORE_CORS}
      - ADMIN_CORS=${ADMIN_CORS}
      - AUTH_CORS=${AUTH_CORS}
      - DISABLE_MEDUSA_ADMIN=${DISABLE_MEDUSA_ADMIN:-true}
      - MEDUSA_BACKEND_URL=${MEDUSA_BACKEND_URL}
      - MEDUSA_WORKER_MODE=${MEDUSA_WORKER_MODE:-server}
    # No volumes in production
    ports:
      - "${BACKEND_PORT:-9000}:9000"
    command: ["npm", "run", "start"]
    deploy:
      replicas: 2
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 512M

  storefront:
    restart: unless-stopped
    environment:
      - NODE_ENV=production
      - NEXT_PUBLIC_MEDUSA_BACKEND_URL=${NEXT_PUBLIC_MEDUSA_BACKEND_URL}
      - NEXT_PUBLIC_BASE_URL=${NEXT_PUBLIC_BASE_URL}
    # No volumes in production
    ports:
      - "${STOREFRONT_PORT:-3000}:3000"
    command: ["npm", "run", "start"]
    deploy:
      replicas: 2
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M